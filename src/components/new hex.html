<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hexagonal Pattern with Glow</title>
    <style>
        /* Basic CSS to make the canvas fill the entire screen */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1a2d; /* A dark blue background color */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- The canvas element where the 3D scene will be rendered -->
    <canvas id="bg"></canvas>

    <!-- Import the main three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Import ALL the necessary post-processing scripts -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // --- SCENE SETUP ---
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set (4, 1, 16); 

        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg'),
            antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // --- LIGHTING ---

        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x88c7f4, 0.8);
        directionalLight.position.set(80, 50, 51);
        scene.add(directionalLight);
        
        // --- HEXAGON CREATION & MATERIALS ---

        const hexGroup = new THREE.Group();
        scene.add(hexGroup);
        
        camera.lookAt(hexGroup.position);

        const hexShape = new THREE.Shape();
        const hexRadius = 2.75;
        const sides = 6;
        const rotationOffset = Math.PI / 6;

        for (let i = 0; i <= sides; i++) {
            const angle = (i / sides) * Math.PI * 2 + rotationOffset;
            const x = hexRadius * Math.cos(angle);
            const y = hexRadius * Math.sin(angle);
            if (i === 0) hexShape.moveTo(x, y);
            else hexShape.lineTo(x, y);
        }

        const faceMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a3a69,
            metalness: 0.6,
            roughness: 0.3
        });

        const sideMaterial = new THREE.MeshStandardMaterial({
            color: 0x102a50,
            metalness: 0.6,
            roughness: 0.3
        });
        
        const highlightMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0xffd700,
            emissiveIntensity: 1.0 
        });


        // --- GRID LAYOUT ---

        const hexGridWidth = Math.sqrt(3) * hexRadius;
        const hexGridHeight = 2 * hexRadius;
        const spacing = 1.23;

        const gridRows = 20;
        const gridCols = 20;

        for (let row = -Math.floor(gridRows/2); row < Math.ceil(gridRows/2); row++) {
            for (let col = -Math.floor(gridCols/2); col < Math.ceil(gridCols/2); col++) {
                
                const extrudeSettings = {
                    steps: 1,
                    // ** BUG FIX ** Corrected the random depth calculation
                    depth: 0.2 + (Math.random() * 0.1), 
                    bevelEnabled: true,
                    // ** BUG FIX ** Reset bevel settings to be more subtle and clean
                    bevelThickness: 0.2,
                    bevelSize: 0.29,
                    bevelOffset: 0,
                    bevelSegments: 8
                };
                
                const hexGeometry = new THREE.ExtrudeGeometry(hexShape, extrudeSettings);
                const materials = [faceMaterial, sideMaterial, faceMaterial];

                // ** FIXED ** Check if this hexagon should be highlighted
                if (Math.random() < 0.3) {
                    // ** FIXED ** Target the bevel edge (index 2)
                    materials[2] = highlightMaterial;
                }

                const hexagon = new THREE.Mesh(hexGeometry, materials);

                const horizontalSpacing = hexGridWidth * spacing;
                const verticalSpacing = hexGridHeight * 0.75 * spacing;
                let x = col * horizontalSpacing;
                const y = row * verticalSpacing;
                if (Math.abs(row) % 2 === 1) {
                     x += horizontalSpacing / 2;
                }
                hexagon.position.set(x, y, 0);
                hexagon.rotation.x = Math.random() * 0.05 - 0.025;
                hexagon.rotation.y = Math.random() * 0.05 - 0.025;
                hexGroup.add(hexagon);
            }
        }

        // --- BASE PLANE ---
        
        const totalGridWidth = gridCols * hexGridWidth * spacing;
        const totalGridHeight = gridRows * hexGridHeight * 0.75 * spacing;
        const planeGeometry = new THREE.PlaneGeometry(totalGridWidth, totalGridHeight);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0f2a57,
            metalness: 0.5,
            roughness: 0.5
        });
        const basePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        basePlane.position.z = -0.01; 
        scene.add(basePlane);

        // --- POST-PROCESSING PIPELINE ---

        const renderScene = new THREE.RenderPass(scene, camera);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        
        // Corrected bloom settings to make the glow visible
        bloomPass.threshold = 0.01; // Only affects very bright things (our emissive material)
        bloomPass.strength = 1.0;  // How strong the glow is
        bloomPass.radius = 0.90;    // How far the glow spreads

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        
        // --- RESPONSIVENESS ---

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height); // Also resize the composer
        }

        // --- RENDER ---
        
        // Render using the composer to apply the bloom effect
        composer.render();

        window.addEventListener('resize', () => {
             onWindowResize();
             composer.render();
        });

    </script>
</body>
</html>
